# -*- coding: utf-8 -*-
"""DeepLearning_Modeling 12.10.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TAIHj9x8Hetn9aah2TCWCSvYXooexXGH

# Practical example. Audiobooks

## Problem

You are given data from an Audiobook app. Logically, it relates only to the audio versions of books. Each customer in the database has made a purchase at least once, that's why he/she is in the database. We want to create a machine learning algorithm based on our available data that can predict if a customer will buy again from the Audiobook company.

The main idea is that if a customer has a low probability of coming back, there is no reason to spend any money on advertizing to him/her. If we can focus our efforts ONLY on customers that are likely to convert again, we can make great savings. Moreover, this model can identify the most important metrics for a customer to come back again. Identifying new customers creates value and growth opportunities.

You have a .csv summarizing the data. There are several variables: Customer ID, Book length in mins_avg (average of all purchases), Book length in minutes_sum (sum of all purchases), Price Paid_avg (average of all purchases), Price paid_sum (sum of all purchases), Review (a Boolean variable), Review (out of 10), Total minutes listened, Completion (from 0 to 1), Support requests (number), and Last visited minus purchase date (in days).

So these are the inputs (excluding customer ID, as it is completely arbitrary. It's more like a name, than a number).

The targets are a Boolean variable (so 0, or 1). We are taking a period of 2 years in our inputs, and the next 6 months as targets. So, in fact, we are predicting if: based on the last 2 years of activity and engagement, a customer will convert in the next 6 months. 6 months sounds like a reasonable time. If they don't convert after 6 months, chances are they've gone to a competitor or didn't like the Audiobook way of digesting information. 

The task is simple: create a machine learning algorithm, which is able to predict if a customer will buy again. 

This is a classification problem with two classes: won't buy and will buy, represented by 0s and 1s. 

Good luck!

## Create the machine learning algorithm

### Import the relevant libraries
"""

import numpy as np
import tensorflow as tf

"""### Data"""

from google.colab import drive
drive.mount('/content/drive')

#Load the npz file we created
npz = np.load('/content/drive/My Drive/Customer Analytics/Audiobooks_data_train.npz')

train_inputs = npz['inputs'].astype(np.float)
train_targets = npz['targets'].astype(np.int)

npz = np.load('/content/drive/My Drive/Customer Analytics/Audiobooks_data_validation.npz')
validation_inputs, validation_targets = npz['inputs'].astype(np.float), npz['targets'].astype(np.int)

npz = np.load('/content/drive/My Drive/Customer Analytics/Audiobooks_data_test.npz')
test_inputs, test_targets = npz['inputs'].astype(np.float), npz['targets'].astype(np.int)

"""### Model
Outline, optimizers, loss, early stopping and training
"""

#input_size = 10
#Set the output size
output_size = 2
hidden_layer_size = 50

#Define the model
model = tf.keras.Sequential([
                            tf.keras.layers.Dense(hidden_layer_size, activation='relu'),
                            tf.keras.layers.Dense(hidden_layer_size, activation='relu'),
                            tf.keras.layers.Dense(output_size, activation='softmax')    
                            ])
#Choose the optimizer and the loss function
model.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics = ['accuracy'])

#Training the function, set the batch size, max epochs and early stopping 
batch_size = 100

max_epochs=100

early_stopping = tf.keras.callbacks.EarlyStopping(patience=2)

#Fit the model
model.fit(train_inputs,
          train_targets,
          batch_size=batch_size,
          epochs=max_epochs,
          callbacks=[early_stopping],
          validation_data=(validation_inputs, validation_targets),
          verbose=2
          )

"""## Test the model"""

#Utilize the evaluate function to get the loss and accuracy.
test_loss, test_accuracy = model.evaluate(test_inputs, test_targets)

#Print formatted result
print('\nTest loss: {0:.2f}. Test accuracy: {1:.2f}%'.format(test_loss, test_accuracy*100.))

"""## Obtain the probability for a customer to convert"""

#Predict the probability of test dataset.
model.predict(test_inputs).round(2)

model.predict(test_inputs)[:,1].round(0)

#Utilize the argmax function to get the position of highest number.
np.argmax(model.predict(test_inputs), axis=1)

"""## Save the model"""

model.save('audiobooks_model.h5')

# Commented out IPython magic to ensure Python compatibility.
# %cp audiobooks_model.h5 ./drive/MyDrive/

